first = c(1:30)
second = c(seq(31,148, by = 4))
third = c(seq(149, 382, by = 8))
data_6 = c(first, second)
test_data_6 = data.frame(time, data_6)
bkpts_6 = breakpoints(test_data_6$data_6 ~ test_data_6$time, breaks = 5, h = 0.1)
first = c(1:30)
second = c(seq(31,148, by = 4))
third = c(seq(149, 382, by = 8))
data_6 = c(first, second)
test_data_6 = data.frame(time, data_6)
data_6 = c(first, second, third)
test_data_6 = data.frame(time, data_6)
bkpts_6 = breakpoints(test_data_6$data_6 ~ test_data_6$time, breaks = 5, h = 0.1)
plot(test_data_6)
first = c(seq(1,15, by = .5))
second = c(16:61)
data_7 = c(first, second)
test_data_7 = data.frame(time, data_7)
length(first)
length(first)
first = c(seq(1,30, by = .5))
length(first)
first = c(seq(1,31, by = .5))
length(first)
first = c(seq(1,20, by = .5))
length(first)
first = c(seq(1,25, by = .5))
length(first)
first = c(seq(1,23, by = .5))
length(first)
first = c(seq(1,23, by = .5))
second = c(16:61)
data_7 = c(first, second)
test_data_7 = data.frame(time, data_7)
bkpts_7 = breakpoints(test_data_7$data_7 ~ test_data_7$time, breaks = 5, h = 0.1)
test_data_7 = data.frame(time, data_7)
second = c(24:68)
data_7 = c(first, second)
test_data_7 = data.frame(time, data_7)
bkpts_7 = breakpoints(test_data_7$data_7 ~ test_data_7$time, breaks = 5, h = 0.1)
plot(test_data_7)
first = c(1,15, by = .25)
length(first)
first = c(1,15, by = .25)
length(first)
first
first = c(seq(1,15, by = .25))
length(first)
first = c(seq(1,10, by = .25))
length(first)
first = c(seq(1,6, by = .25))
length(first)
8
first = c(seq(1,,8 by = .25))
first = c(seq(1,8, by = .25))
length(first)
first = c(seq(1,8.25, by = .25))
length(first)
second = c(seq(8.5,15, by = .5))
length(second)
second = c(seq(8.5,16, by = .5))
length(second)
second = c(seq(8.5,15, by = .5))
length(second)
second = c(seq(8.5,15.5, by = .5))
length(second)
second = c(seq(8.5,30.5, by = .5))
length(second)
second = c(seq(8.5,20.5, by = .5))
length(second)
second = c(seq(8.5,25.5, by = .5))
length(second)
second = c(seq(8.5,23.5, by = .5))
length(second)
second = c(seq(8.5,23, by = .5))
length(second)
third = c(seq(24, 50, by = 1))
length(third)
third = c(seq(24, 53, by = 1))
length(third)
data_8 = c(first, second, third)
test_data_8 = data.frame(time, data_8)
plot(test_data_8)
third = c(seq(24, 50, by = .75))
length(third)
third = c(seq(24, 48, by = .75))
length(third)
third = c(seq(24, 46, by = .75))
length(third)
first = c(seq(1,8.25, by = .25))
second = c(seq(8.5,23, by = .5))
third = c(seq(24, 46, by = .75))
data_8 = c(first, second, third)
test_data_8 = data.frame(time, data_8)
plot(thest_data_8)
plot(test_data_8)
bkpts_8 = breakpoints(test_data_8$data_8 ~ test_data_8$time, breaks = 5, h = 0.1)
par(mfrow=c(3,3))
plot(test_data_0)
plot(test_data_1)
plot(test_data_2)
plot(test_data_3)
plot(test_data_4)
plot(test_data_5)
plot(test_data_6)
plot(test_data_7)
plot(test_data_8)
par(mfrow=c(1,1))
par(mfrow=c(3,3))
plot(test_data_0, main = "No Breaks")
plot(test_data_1, main = "One Break, Small Variance")
plot(test_data_2, main = "Two Breaks, Small Variance")
plot(test_data_3, main = "One Break, Big Variance")
plot(test_data_4, main = "Two Breaks, Big Variance")
plot(test_data_5, main = "One Break and big differnent Slopes")
plot(test_data_6, main = "Two Breaks and big different Slopes ")
plot(test_data_7, main = "One Break and small slopes")
plot(test_data_8, main = "Two Breaks and small slopes")
par(mfrow=c(1,1))
par(mfrow=c(3,3))
plot(test_data_0, main = "No Breaks")
plot(test_data_1, main = "One Break, Small Variance")
plot(test_data_2, main = "Two Breaks, Small Variance")
plot(test_data_3, main = "One Break, Big Variance")
plot(test_data_4, main = "Two Breaks, Big Variance")
plot(test_data_5, main = "One Break and Big Slopes")
plot(test_data_6, main = "Two Breaks and Big Slopes ")
plot(test_data_7, main = "One Break and Small Slopes")
plot(test_data_8, main = "Two Breaks and Small Slopes")
par(mfrow=c(1,1))
rm(list=ls())
graphics.off()
cat("\014")
library("strucchange")
time = 1:90
data_0 = rnorm(90, mean = 10, sd = 1)
test_data_0 = data.frame(time, data_0)
bkpts_0 = breakpoints(test_data_0$data_0 ~ test_data_0$time, breaks = 5, h = 0.1)
first = rnorm(45, mean = 10, sd = 1)
second = rnorm(45, mean = 20, sd = 1)
data_1 = c(first, second)
test_data_1 = data.frame(time, data_1)
bkpts_1 = breakpoints(test_data_1$data_1 ~ test_data_1$time, breaks = 5, h = 0.1)
first = rnorm(30, mean = 5, sd = 1)
second = rnorm(30, mean = 15, sd = 1)
third = rnorm(30, mean = 30, sd = 1)
data_2 = c(first, second, third)
test_data_2 = data.frame(time, data_2)
bkpts_2 = breakpoints(test_data_0$data_2 ~ test_data_2$time, breaks = 5, h = 0.1)
first = rnorm(45, mean = 10, sd = 5)
second = rnorm(45, mean = 20, sd = 5)
data_3 = c(first, second)
test_data_3 = data.frame(time, data_3)
bkpts_3 = breakpoints(test_data_0$data_3 ~ test_data_3$time, breaks = 5, h = 0.1)
first = rnorm(30, mean = 5, sd = 6)
rm(list=ls())
library("strucchange")
time = 1:90
data_0 = rnorm(90, mean = 10, sd = 1)
test_data_0 = data.frame(time, data_0)
bkpts_0 = breakpoints(test_data_0$data_0 ~ test_data_0$time, breaks = 5, h = 0.1)
first = rnorm(45, mean = 10, sd = 1)
second = rnorm(45, mean = 20, sd = 1)
data_1 = c(first, second)
test_data_1 = data.frame(time, data_1)
bkpts_1 = breakpoints(test_data_1$data_1 ~ test_data_1$time, breaks = 5, h = 0.1)
first = rnorm(30, mean = 5, sd = 1)
second = rnorm(30, mean = 15, sd = 1)
third = rnorm(30, mean = 30, sd = 1)
data_2 = c(first, second, third)
test_data_2 = data.frame(time, data_2)
bkpts_2 = breakpoints(test_data_2$data_2 ~ test_data_2$time, breaks = 5, h = 0.1)
first = rnorm(45, mean = 10, sd = 5)
second = rnorm(45, mean = 20, sd = 5)
data_3 = c(first, second)
test_data_3 = data.frame(time, data_3)
bkpts_3 = breakpoints(test_data_3$data_3 ~ test_data_3$time, breaks = 5, h = 0.1)
first = rnorm(30, mean = 5, sd = 6)
second = rnorm(30, mean = 20, sd = 6)
third = rnorm(30, mean = 35, sd = 6)
data_4 = c(first, second, third)
test_data_4 = data.frame(time, data_4)
bkpts_4 = breakpoints(test_data_4$data_4 ~ test_data_4$time, breaks = 5, h = 0.1)
first = c(1:45)
second = c(seq(46, 224, by = 4))
data_5 = c(first, second)
test_data_5 = data.frame(time, data_5)
bkpts_5 = breakpoints(test_data_5$data_5 ~ test_data_5$time, breaks = 5, h = 0.1)
first = c(1:30)
second = c(seq(31,148, by = 4))
third = c(seq(149, 382, by = 8))
data_6 = c(first, second, third)
test_data_6 = data.frame(time, data_6)
bkpts_6 = breakpoints(test_data_6$data_6 ~ test_data_6$time, breaks = 5, h = 0.1)
first = c(seq(1,23, by = .5))
second = c(24:68)
data_7 = c(first, second)
test_data_7 = data.frame(time, data_7)
bkpts_7 = breakpoints(test_data_7$data_7 ~ test_data_7$time, breaks = 5, h = 0.1)
first = c(seq(1,8.25, by = .25))
second = c(seq(8.5,23, by = .5))
third = c(seq(24, 46, by = .75))
data_8 = c(first, second, third)
test_data_8 = data.frame(time, data_8)
bkpts_8 = breakpoints(test_data_8$data_8 ~ test_data_8$time, breaks = 5, h = 0.1)
par(mfrow=c(3,3))
plot(test_data_0, main = "No Breaks")
plot(test_data_1, main = "One Break, Small Variance")
plot(test_data_2, main = "Two Breaks, Small Variance")
plot(test_data_3, main = "One Break, Big Variance")
plot(test_data_4, main = "Two Breaks, Big Variance")
plot(test_data_5, main = "One Break and Big Slopes")
plot(test_data_6, main = "Two Breaks and Big Slopes ")
plot(test_data_7, main = "One Break and Small Slopes")
plot(test_data_8, main = "Two Breaks and Small Slopes")
par(mfrow=c(1,1))
rm(list=ls())
graphics.off()
cat("\014")
k_ends_test = c(1,50,60)
barMake1<-function(k_ends){
d = diff(k_ends) #finding the distance between all those breakpoints
locations = which(d == max(d) ) #finding the location(s) of the farthest distance
location = sample(locations, 1) #randomly select location in case of equal max distances
min = k_ends[location] #lower bound
max = k_ends[location + 1] #upper bound
new_bp = sample((min+1):(max-1), 1) #selecting a random number in the correct interval
k_ends_final = sort(c(k_ends_final, new_bp))
return(k_ends_final)
}
barMake1(k_ends_test)
k_ends_final = NULL
barMake1<-function(k_ends){
d = diff(k_ends) #finding the distance between all those breakpoints
locations = which(d == max(d) ) #finding the location(s) of the farthest distance
location = sample(locations, 1) #randomly select location in case of equal max distances
min = k_ends[location] #lower bound
max = k_ends[location + 1] #upper bound
new_bp = sample((min+1):(max-1), 1) #selecting a random number in the correct interval
k_ends_final = sort(c(k_ends_final, new_bp))
return(k_ends_final)
}
barMake1(k_ends_test)
k_ends_test = c(1,50,60)
k_ends_final = NULL
barMake1<-function(k_ends){
d = diff(k_ends) #finding the distance between all those breakpoints
locations = which(d == max(d) ) #finding the location(s) of the farthest distance
location = sample(locations, 1) #randomly select location in case of equal max distances
min = k_ends[location] #lower bound
max = k_ends[location + 1] #upper bound
new_bp = sample((min+1):(max-1), 1) #selecting a random number in the correct interval
k_ends_final = sort(c(k_ends, new_bp))
return(k_ends_final)
}
barMake1(k_ends_test)
rm(list=ls())
k_ends_test = c(1,50,60)
barMake1<-function(k_ends){
d = diff(k_ends) #finding the distance between all those breakpoints
locations = which(d == max(d) ) #finding the location(s) of the farthest distance
location = sample(locations, 1) #randomly select location in case of equal max distances
min = k_ends[location] #lower bound
max = k_ends[location + 1] #upper bound
new_bp = sample((min+1):(max-1), 1) #selecting a random number in the correct interval
k_ends_final = sort(c(k_ends, new_bp))
return(k_ends_final)
}
barMake1(k_ends_test)
k_ends_test = c(1,50,60)
barMake2<-function(k_ends){
#random number generator
proposed = sample(1:max(k_ends), 2)
proposed = sort(proposed) #sorting the 2 chosen numbers
#setting up initial values
small_1 = list()
big_1 = list()
small_2 = list()
big_2 = list()
#finding which points are closest to the propsed break points
for(i in 1:length(k_ends)) {
if(proposed[1] > k_ends[i] ) {
small_1 = c(small_1, k_ends[i])
} else {
big_1 = c(big_1, k_ends[i])
}
if(proposed[2] > k_ends[i]) {
small_2 = c(small_2, k_ends[i])
} else {
big_2 = c(big_2, k_ends[i])
}
}
#this is extremely convaluted and not the best way
one = 0
two = 0
#looking at first point
if(length(small_1) == 0) {
one = c(1, proposed[[1]][1], big_1[which.min(big_1)][[1]][1])
} else if(length(big_1) == 0) {
one = c(small_1[which.max(small_1)][[1]][1], proposed[[1]][1], max(k_ends))
} else {
one = c(small_1[which.max(small_1)][[1]][1], proposed[[1]][1], big_1[which.min(big_1)][[1]][1])
}
#looking at second point
if(length(small_2) == 0) {
two = c(1, proposed[[2]][1], big_2[which.min(big_2)][[1]][1])
} else if(length(big_2) == 0) {
two = c(small_2[which.max(small_2)][[1]][1], proposed[[2]][1], max(k_ends))
} else {
two = c(small_2[which.max(small_2)][[1]][1], proposed[[2]][1], big_2[which.min(big_2)][[1]][1])
}
#finding the distance between the points
d_one = diff(one)
d_two = diff(two)
#sorting the distance
d_one_sort = sort(d_one)
d_two_sort = sort(d_two)
new_bp = 0
if(d_one_sort[1] == d_two_sort[1]) { #comparing the mins, if equal, look at max
if(d_one_sort[2] == d_two_sort[2]) {  #if both the min length and the max length are equal, randomize
r = runif(1) #generating a random number
if(r > 0.5) {
new_bp = proposed[2]
} else {
new_bp = proposed[1]
}
} else if(d_one_sort[2] < d_two_sort[2]) { #comparing the max to determine new point
new_bp = proposed[2]
} else {
new_bp = proposed[1]
}
} else if(d_one_sort[1] < d_two_sort[1]) { #comparing the min to see the new break point
new_bp = proposed[2]
} else {
new_bp = proposed[1]
}
k_ends_final = sort(c(k_ends, new_bp))
return(k_ends_final)
}
barMake2(k_ends_test)
rm(list=ls())
k_ends_test = c(1,50,60)
barMake2<-function(k_ends){
#random number generator
proposed = sample(1:max(k_ends), 2)
proposed = sort(proposed) #sorting the 2 chosen numbers
#setting up initial values
small_1 = list()
big_1 = list()
small_2 = list()
big_2 = list()
#finding which points are closest to the propsed break points
for(i in 1:length(k_ends)) {
if(proposed[1] > k_ends[i] ) {
small_1 = c(small_1, k_ends[i])
} else {
big_1 = c(big_1, k_ends[i])
}
if(proposed[2] > k_ends[i]) {
small_2 = c(small_2, k_ends[i])
} else {
big_2 = c(big_2, k_ends[i])
}
}
#this is extremely convaluted and not the best way
one = 0
two = 0
#looking at first point
if(length(small_1) == 0) {
one = c(1, proposed[[1]][1], big_1[which.min(big_1)][[1]][1])
} else if(length(big_1) == 0) {
one = c(small_1[which.max(small_1)][[1]][1], proposed[[1]][1], max(k_ends))
} else {
one = c(small_1[which.max(small_1)][[1]][1], proposed[[1]][1], big_1[which.min(big_1)][[1]][1])
}
#looking at second point
if(length(small_2) == 0) {
two = c(1, proposed[[2]][1], big_2[which.min(big_2)][[1]][1])
} else if(length(big_2) == 0) {
two = c(small_2[which.max(small_2)][[1]][1], proposed[[2]][1], max(k_ends))
} else {
two = c(small_2[which.max(small_2)][[1]][1], proposed[[2]][1], big_2[which.min(big_2)][[1]][1])
}
#finding the distance between the points
d_one = diff(one)
d_two = diff(two)
#sorting the distance
d_one_sort = sort(d_one)
d_two_sort = sort(d_two)
new_bp = 0
if(d_one_sort[1] == d_two_sort[1]) { #comparing the mins, if equal, look at max
if(d_one_sort[2] == d_two_sort[2]) {  #if both the min length and the max length are equal, randomize
r = runif(1) #generating a random number
if(r > 0.5) {
new_bp = proposed[2]
} else {
new_bp = proposed[1]
}
} else if(d_one_sort[2] < d_two_sort[2]) { #comparing the max to determine new point
new_bp = proposed[2]
} else {
new_bp = proposed[1]
}
} else if(d_one_sort[1] < d_two_sort[1]) { #comparing the min to see the new break point
new_bp = proposed[2]
} else {
new_bp = proposed[1]
}
k_ends_final = sort(c(k_ends, new_bp))
return(k_ends_final)
}
barMake2(k_ends_test)
k_ends_test = c(1, 20, 40, 60, 80)
barMurder1 <- function(k_ends){
all_intv = diff(k_ends) #finds all of the intervals
sum_intv = diff(cumsum(all_intv)) #finds the sums of the adjacent intervals
small_intv_loc = which(sum_intv == min(sum_intv)) #stores indexes of smallest sum_intv
min_intv_loc = 0 #sets the minimum sum_intv index to 0
#if there's only one small sum_intv
#{the location in sum_intv is equal to the single value in small_intv_loc}
if(length(small_intv_loc) == 1){
min_intv_loc = small_intv_loc[1]
}
#if there are multiple small sum_intv
#{pick a random number from 1-length of small_intv_loc
#location od the smallest interval in sum_intv is equal to the value in small_intv_loc[random#]}
else{
num = sample(1:length(small_intv_loc), 1)
min_intv_loc = small_intv_loc[num]
}
#find and delete correct break
k_ends_final = k_ends[-(min_intv_loc+1)]
return(k_ends_final)
}
barMurder1(k_ends_test)
k_ends_test = c(1,20,30,44,50,60)
barMurder2 <- function(k_ends){
#removing the end points
k<-k_ends[-c(1,length(k_ends))]
#random number generator
proposed = sample(1:length(k), 2, replace = FALSE) #looking at length of k
proposed = sort(proposed) #sorting the 2 chosen numbers
#setting up initial values
small_1 = list()
big_1 = list()
small_2 = list()
big_2 = list()
#finding which points are closest to the propsed break points
for(i in 1:length(k_ends)) {
if(k[proposed[1]] > k_ends[i] ) {
small_1 = c(small_1, k_ends[i])
} else if (k[proposed[1]] < k_ends[i] ){
big_1 = c(big_1, k_ends[i])
}
if(k[proposed[2]] > k_ends[i]) {
small_2 = c(small_2, k_ends[i])
} else if (k[proposed[2]] < k_ends[i]){
big_2 = c(big_2, k_ends[i])
}
}
one = 0
two = 0
#looking at first point
if(length(small_1) == 0) {
one = c(1, proposed[[1]][1], big_1[which.min(big_1)][[1]][1])
} else if(length(big_1) == 0) {
one = c(small_1[which.max(small_1)][[1]][1], proposed[[1]][1], max(k_ends))
} else {
one = c(small_1[which.max(small_1)][[1]][1], proposed[[1]][1], big_1[which.min(big_1)][[1]][1])
}
#looking at second point
if(length(small_2) == 0) {
two = c(1, proposed[[2]][1], big_2[which.min(big_2)][[1]][1])
} else if(length(big_2) == 0) {
two = c(small_2[which.max(small_2)][[1]][1], proposed[[2]][1], max(k_ends))
} else {
two = c(small_2[which.max(small_2)][[1]][1], proposed[[2]][1], big_2[which.min(big_2)][[1]][1])
}
#finding the distance between the points
d_one = diff(one)
d_two = diff(two)
#sorting the distance
d_one_sort = sort(d_one)
d_two_sort = sort(d_two)
new_bp = 0
if(d_one_sort[1] == d_two_sort[1]) { #comparing the mins, if equal, look at max
if(d_one_sort[2] == d_two_sort[2]) {  #if both the min length and the max length are equal, randomize
r = runif(1) #generating a random number
if(r > 0.5) {
new_bp = proposed[2]
} else {
new_bp = proposed[1]
}
} else if(d_one_sort[2] > d_two_sort[2]) { #comparing the max to determine new point
new_bp = proposed[2]
} else {
new_bp = proposed[1]
}
} else if(d_one_sort[1] > d_two_sort[1]) { #comparing the min to see the new break point
new_bp = proposed[2]
} else {
new_bp = proposed[1]
}
#deleting the selecting knot
k_ends_final <- k_ends[-new_bp]
return(k_ends_final)
}
barMurder2(k_ends_test)
rm(list=ls())
graphics.off()
cat("\014")
