random_num = sample(1:length(k), 1)
k_ends_final = k_ends[-(random_num+1)]
k_ends_final
}
#kills a point randomly and then adds a point randomly
barMove0<-function(k_ends){
k_ends_less = barMurder0(k_ends)
k_ends_final = barMake0(k_ends_less)
k_ends_final
}
#initializing matrixes
ratio_data = matrix(NA, nrow=1, ncol=6)
all_k_new = matrix(NA, nrow=1, ncol=(n/3))
all_k_best = matrix(NA, nrow=1, ncol=(n/3))
#Metroplis Hastings
for(i in 1:iterations){
old_metrics = fitMetrics(k_ends, full_data)
sigma_old = old_metrics[1]
SSE_old = old_metrics[2]
u_step = runif(1) #random number from 0 to 1 taken from a uniform distribution for selecting step
if(length(k_ends) < 3 | u_step < prob_mmm[1]){
c_step = "make"
} else if(u_step > prob_mmm[1] & u_step < sum(prob_mmm)){
c_step = "murder"
} else{
c_step = "move"
}
if(c_step == "make"){
k_ends_new = barMake0(k_ends)
} else if (c_step == "murder"){
k_ends_new = barMurder0(k_ends)
} else{
k_ends_new = barMove0(k_ends)
}
new_metrics = fitMetrics(k_ends_new, full_data)
sigma_new = new_metrics[1]
SSE_new = new_metrics[2]
ratio = exp((-1*n*log((sqrt(2*pi)*sigma_new)+0.00001)-(1/(2*sigma_new^2+0.00001))*SSE_new)+((n*log(sqrt(2*pi)*sigma_old)+0.00001)-(1/(2*sigma_old^2+0.00001))*SSE_old))
u_ratio = runif(1) #random number from 0 to 1 taken from a uniform distribution
if(ratio > u_ratio) {
choice = "new"
} else {
choice = "old"
}
if(choice == "new"){
k_ends = k_ends_new
}else{
k_ends = k_ends
}
ratio_data_print = c(ratio, u_ratio, sigma_new, SSE_new, sigma_old, SSE_old)
k_ends_new_print = c(k_ends_new, rep(NA, (n/3)-length(k_ends_new)))
k_ends_best_print = c(k_ends, rep(NA, (n/3)-length(k_ends)))
ratio_data = rbind(ratio_data, ratio_data_print)
all_k_new = rbind(all_k_new, k_ends_new_print)
all_k_best = rbind(all_k_best, k_ends_best_print)
}
#cleaning up the matrixs
ratio_data = ratio_data[-1,]
all_k_new = all_k_new[-1,colSums(is.na(all_k_new))<nrow(all_k_new)]
all_k_best = all_k_best[-1,colSums(is.na(all_k_best))<nrow(all_k_best)]
#plotting
plot(neuron_time, main = 1, xlab = "Time (ms)", ylab = "Number of Neurons Firing")
points(all_k_new[1,],neuron_time[all_k_new[1,],2], col="blue", pch= 16, cex = 2)
points(all_k_best[1,],neuron_time[all_k_best[1,],2], col="red", pch= 16, cex=2)
for(i in 1:20) {
n = i * 5
plot(neuron_time, main = n, xlab = "Time (ms)", ylab = "Number of Neurons Firing")
points(all_k_new[n,],neuron_time[all_k_new[n,],2], col="blue", pch= 16, cex = 2)
points(all_k_best[n,],neuron_time[all_k_best[n,],2], col="red", pch= 16, cex = 2)
}
#prints the results
print(ratio_data)
print(all_k_new)
print(all_k_best)
}
#calling the function
bar0(bkpts_neuron$breakpoints, rownames(neuron), neuron$V2, 100, 0.6, 0.2)
#FUNCTION ONE
#makes a list of mins and maxes for all of the breakpoints
#input is the list of breakpoints and endpoints
list_of_scores <- function(k_ends){
#takes the ends off of k_ends so just looking at the breakpoints will be easier
k_no_ends = k_ends[-c(1,length(k_ends))]
#establishes the list of scores globally
scores_list = list()
#goes through each breakpoint and finds distances between it and neighbors
#concatenates mins and maxes, in order, to scores_list
for(i in 1:length(k_no_ends)){
#sets up the variables
l = 0
r = 0
min = 0
max = 0
if(i == 1){ #first breakpoint has an endpoint as a neighbor
l = k_no_ends[i] - k_ends[i] #distance between breakpoint and left endpoint
r = k_no_ends[i+1] - k_no_ends[i] #distance between breakpoint and right neighbor
}
else if (i == length(k_no_ends)){#last breakpoint has an endpoint as a neighbor
l = k_no_ends[i] - k_no_ends[i-1]#distance between breakpoint and left neighbor
r = k_ends[length(k_ends)] - k_no_ends[i]#distance between breakpoint and right endpoint
}
else{#general case
l = k_no_ends[i]-k_no_ends[i-1] #distance between breakpoint and left neighbor
r = k_no_ends[i+1]-k_no_ends[i] #distance between breakpoint and right neighbor
}
#gives the min and maxes the correct values
if(r>l){
max = r
min = l
}else{
max = l
min = r
}
#adds the mins and the maxes to the score_list
scores_list = c(scores_list, min, max, recursive=T)
}
return(scores_list)
}
breakpoint_win_count <- function(k_ends_old, k_ends_new){
#setting up global variables to use later
win_counter = 0
tie_counter = 0
losses_counter = 0 #just to check that I can do addition
min_bkpt = 0
max_bkpt = 0
#finds what exactly what the delted breakpoint is
dead_bkpt = setdiff(k_ends_old,k_ends_new)
#finds location of deleted break point in the original k_ends
dead_bkpt_grave = 0
for(i in 1:length(k_ends_old)){
if (k_ends_old[i] == dead_bkpt){
dead_bkpt_grave = i
}
}
#sets the min and max scores for the deleted breakpoint
right = k_ends_old[dead_bkpt_grave]-k_ends_old[dead_bkpt_grave-1]
left = k_ends_old[dead_bkpt_grave+1]-k_ends_old[dead_bkpt_grave]
if(right > left){
max_bkpt = right
min_bkpt = left
}else{
max_bkpt = left
min_bkpt = right
}
scoring_list = list_of_scores(k_ends_old)  #calculates a scoring list for k_ends_old
hasWon = "no" #boolean will check to see if the point has already won match
#goes through the list and counts wins, ties, and losses
for(i in 1:length(scoring_list)){
if(i %% 2 != 0){#if i is odd, we're looking at minimums for the first time
hasWon = "no" #just makes sure that hasWon is set to no
if(min_bkpt< scoring_list[i]){ #if the breakpoint's minimum is less than the scorelist it won minimum
win_counter = win_counter+1 #increase the win counter by 1
hasWon = "yes" #the break point won so nothing else will need to happen
}#if(min_bkpt >= scoring_list[i]) don't do anything
}else if (i %% 2 == 0 && hasWon == "no"){#if i is even and it hasnt won, look at the maximum
if(max_bkpt < scoring_list[i]){#if the breakpoint's maximum is less than the scorelit it won maximum
win_counter = win_counter+1 #increase the win counter by 1
}
else if(max_bkpt == scoring_list[i]){#if they're equal, then it's a tie
tie_counter = tie_counter+0.5 #increase the tie counter by .5
}
else{#the breakpoint loss =( so increaste the loss counter
losses_counter = losses_+1 #im so sorry for your loss
}
}
}
#with current set up there is an occassion where the point is compared to itself
#such a case will result in a tie
#therefore, we need to remove one tie case
tie_counter = tie_counter-0.5
#now we need to add the total number of wins and ties
total_count = win_counter+tie_counter
return(total_count)
}
#FUNCTION THREE
#calculates the second part of the q algorithm for sub
#inputs: k_ends_old, k_ends_new,
#rhow --- probability of choosing a random subtraction instead of our created subtraction
part_two_q_sub_score <- function(k_ends_old, K_ends_new, rhow){
numerator = breakpoint_win_count(k_ends_old, k_ends_new)
denomenator = choose(length(k_ends_old)-2, 2)
part_2 = (numerator/denomenator)*(1-rhow)+(rhow)*(1/length(k_ends_old)-2)
return(part_2)
}
part_two_q_sub_score(c(1,30,60,90), c(1,30,90), .3)
#FUNCTION ONE
#makes a list of mins and maxes for all of the breakpoints
#input is the list of breakpoints and endpoints
list_of_scores <- function(k_ends){
#takes the ends off of k_ends so just looking at the breakpoints will be easier
k_no_ends = k_ends[-c(1,length(k_ends))]
#establishes the list of scores globally
scores_list = list()
#goes through each breakpoint and finds distances between it and neighbors
#concatenates mins and maxes, in order, to scores_list
for(i in 1:length(k_no_ends)){
#sets up the variables
l = 0
r = 0
min = 0
max = 0
if(i == 1){ #first breakpoint has an endpoint as a neighbor
l = k_no_ends[i] - k_ends[i] #distance between breakpoint and left endpoint
r = k_no_ends[i+1] - k_no_ends[i] #distance between breakpoint and right neighbor
}
else if (i == length(k_no_ends)){#last breakpoint has an endpoint as a neighbor
l = k_no_ends[i] - k_no_ends[i-1]#distance between breakpoint and left neighbor
r = k_ends[length(k_ends)] - k_no_ends[i]#distance between breakpoint and right endpoint
}
else{#general case
l = k_no_ends[i]-k_no_ends[i-1] #distance between breakpoint and left neighbor
r = k_no_ends[i+1]-k_no_ends[i] #distance between breakpoint and right neighbor
}
#gives the min and maxes the correct values
if(r>l){
max = r
min = l
}else{
max = l
min = r
}
#adds the mins and the maxes to the score_list
scores_list = c(scores_list, min, max, recursive=T)
}
return(scores_list)
}
breakpoint_win_count <- function(k_ends_old, k_ends_new){
#setting up global variables to use later
win_counter = 0
tie_counter = 0
losses_counter = 0 #just to check that I can do addition
min_bkpt = 0
max_bkpt = 0
#finds what exactly what the delted breakpoint is
dead_bkpt = setdiff(k_ends_old,k_ends_new)
#finds location of deleted break point in the original k_ends
dead_bkpt_grave = 0
for(i in 1:length(k_ends_old)){
if (k_ends_old[i] == dead_bkpt){
dead_bkpt_grave = i
}
}
#sets the min and max scores for the deleted breakpoint
right = k_ends_old[dead_bkpt_grave]-k_ends_old[dead_bkpt_grave-1]
left = k_ends_old[dead_bkpt_grave+1]-k_ends_old[dead_bkpt_grave]
if(right > left){
max_bkpt = right
min_bkpt = left
}else{
max_bkpt = left
min_bkpt = right
}
scoring_list = list_of_scores(k_ends_old)  #calculates a scoring list for k_ends_old
hasWon = "no" #boolean will check to see if the point has already won match
#goes through the list and counts wins, ties, and losses
for(i in 1:length(scoring_list)){
if(i %% 2 != 0){#if i is odd, we're looking at minimums for the first time
hasWon = "no" #just makes sure that hasWon is set to no
if(min_bkpt< scoring_list[i]){ #if the breakpoint's minimum is less than the scorelist it won minimum
win_counter = win_counter+1 #increase the win counter by 1
hasWon = "yes" #the break point won so nothing else will need to happen
}#if(min_bkpt >= scoring_list[i]) don't do anything
}else if (i %% 2 == 0 && hasWon == "no"){#if i is even and it hasnt won, look at the maximum
if(max_bkpt < scoring_list[i]){#if the breakpoint's maximum is less than the scorelit it won maximum
win_counter = win_counter+1 #increase the win counter by 1
}
else if(max_bkpt == scoring_list[i]){#if they're equal, then it's a tie
tie_counter = tie_counter+0.5 #increase the tie counter by .5
}
else{#the breakpoint loss =( so increaste the loss counter
losses_counter = losses_+1 #im so sorry for your loss
}
}
}
#with current set up there is an occassion where the point is compared to itself
#such a case will result in a tie
#therefore, we need to remove one tie case
tie_counter = tie_counter-0.5
#now we need to add the total number of wins and ties
total_count = win_counter+tie_counter
return(total_count)
}
#FUNCTION THREE
#calculates the second part of the q algorithm for sub
#inputs: k_ends_old, k_ends_new,
#rhow --- probability of choosing a random subtraction instead of our created subtraction
part_two_q_sub_score <- function(k_ends_old, K_ends_new, rhow){
numerator = breakpoint_win_count(k_ends_old, k_ends_new)
denomenator = choose(length(k_ends_old)-2, 2)
part_2 = (numerator/denomenator)*(1-rhow)+(rhow)*(1/length(k_ends_old)-2)
return(part_2)
}
part_two_q_sub_score(c(1,30,60,90), c(1,30,90), .3)
rm(list=ls())
cat("014")
cat("\014")
#FUNCTION ONE
#makes a list of mins and maxes for all of the breakpoints
#input is the list of breakpoints and endpoints
list_of_scores <- function(k_ends){
#takes the ends off of k_ends so just looking at the breakpoints will be easier
k_no_ends = k_ends[-c(1,length(k_ends))]
#establishes the list of scores globally
scores_list = list()
#goes through each breakpoint and finds distances between it and neighbors
#concatenates mins and maxes, in order, to scores_list
for(i in 1:length(k_no_ends)){
#sets up the variables
l = 0
r = 0
min = 0
max = 0
if(i == 1){ #first breakpoint has an endpoint as a neighbor
l = k_no_ends[i] - k_ends[i] #distance between breakpoint and left endpoint
r = k_no_ends[i+1] - k_no_ends[i] #distance between breakpoint and right neighbor
}
else if (i == length(k_no_ends)){#last breakpoint has an endpoint as a neighbor
l = k_no_ends[i] - k_no_ends[i-1]#distance between breakpoint and left neighbor
r = k_ends[length(k_ends)] - k_no_ends[i]#distance between breakpoint and right endpoint
}
else{#general case
l = k_no_ends[i]-k_no_ends[i-1] #distance between breakpoint and left neighbor
r = k_no_ends[i+1]-k_no_ends[i] #distance between breakpoint and right neighbor
}
#gives the min and maxes the correct values
if(r>l){
max = r
min = l
}else{
max = l
min = r
}
#adds the mins and the maxes to the score_list
scores_list = c(scores_list, min, max, recursive=T)
}
return(scores_list)
}
breakpoint_win_count <- function(k_ends_old, k_ends_new){
#setting up global variables to use later
win_counter = 0
tie_counter = 0
losses_counter = 0 #just to check that I can do addition
min_bkpt = 0
max_bkpt = 0
#finds what exactly what the delted breakpoint is
dead_bkpt = setdiff(k_ends_old,k_ends_new)
#finds location of deleted break point in the original k_ends
dead_bkpt_grave = 0
for(i in 1:length(k_ends_old)){
if (k_ends_old[i] == dead_bkpt){
dead_bkpt_grave = i
}
}
#sets the min and max scores for the deleted breakpoint
right = k_ends_old[dead_bkpt_grave]-k_ends_old[dead_bkpt_grave-1]
left = k_ends_old[dead_bkpt_grave+1]-k_ends_old[dead_bkpt_grave]
if(right > left){
max_bkpt = right
min_bkpt = left
}else{
max_bkpt = left
min_bkpt = right
}
scoring_list = list_of_scores(k_ends_old)  #calculates a scoring list for k_ends_old
hasWon = "no" #boolean will check to see if the point has already won match
#goes through the list and counts wins, ties, and losses
for(i in 1:length(scoring_list)){
if(i %% 2 != 0){#if i is odd, we're looking at minimums for the first time
hasWon = "no" #just makes sure that hasWon is set to no
if(min_bkpt< scoring_list[i]){ #if the breakpoint's minimum is less than the scorelist it won minimum
win_counter = win_counter+1 #increase the win counter by 1
hasWon = "yes" #the break point won so nothing else will need to happen
}#if(min_bkpt >= scoring_list[i]) don't do anything
}else if (i %% 2 == 0 && hasWon == "no"){#if i is even and it hasnt won, look at the maximum
if(max_bkpt < scoring_list[i]){#if the breakpoint's maximum is less than the scorelit it won maximum
win_counter = win_counter+1 #increase the win counter by 1
}
else if(max_bkpt == scoring_list[i]){#if they're equal, then it's a tie
tie_counter = tie_counter+0.5 #increase the tie counter by .5
}
else{#the breakpoint loss =( so increaste the loss counter
losses_counter = losses_+1 #im so sorry for your loss
}
}
}
#with current set up there is an occassion where the point is compared to itself
#such a case will result in a tie
#therefore, we need to remove one tie case
tie_counter = tie_counter-0.5
#now we need to add the total number of wins and ties
total_count = win_counter+tie_counter
return(total_count)
}
#FUNCTION THREE
#calculates the second part of the q algorithm for sub
#inputs: k_ends_old, k_ends_new,
#rhow --- probability of choosing a random subtraction instead of our created subtraction
part_two_q_sub_score <- function(k_ends_old, K_ends_new, rhow){
numerator = breakpoint_win_count(k_ends_old, k_ends_new)
denomenator = choose(length(k_ends_old)-2, 2)
part_2 = (numerator/denomenator)*(1-rhow)+(rhow)*(1/length(k_ends_old)-2)
return(part_2)
}
part_two_q_sub_score(c(1,30,60,90), c(1,30,90), .3)
#FUNCTION ONE
#makes a list of mins and maxes for all of the breakpoints
#input is the list of breakpoints and endpoints
list_of_scores <- function(k_ends){
#takes the ends off of k_ends so just looking at the breakpoints will be easier
k_no_ends = k_ends[-c(1,length(k_ends))]
#establishes the list of scores globally
scores_list = list()
#goes through each breakpoint and finds distances between it and neighbors
#concatenates mins and maxes, in order, to scores_list
for(i in 1:length(k_no_ends)){
#sets up the variables
l = 0
r = 0
min = 0
max = 0
if(i == 1){ #first breakpoint has an endpoint as a neighbor
l = k_no_ends[i] - k_ends[i] #distance between breakpoint and left endpoint
r = k_no_ends[i+1] - k_no_ends[i] #distance between breakpoint and right neighbor
}
else if (i == length(k_no_ends)){#last breakpoint has an endpoint as a neighbor
l = k_no_ends[i] - k_no_ends[i-1]#distance between breakpoint and left neighbor
r = k_ends[length(k_ends)] - k_no_ends[i]#distance between breakpoint and right endpoint
}
else{#general case
l = k_no_ends[i]-k_no_ends[i-1] #distance between breakpoint and left neighbor
r = k_no_ends[i+1]-k_no_ends[i] #distance between breakpoint and right neighbor
}
#gives the min and maxes the correct values
if(r>l){
max = r
min = l
}else{
max = l
min = r
}
#adds the mins and the maxes to the score_list
scores_list = c(scores_list, min, max, recursive=T)
}
return(scores_list)
}
breakpoint_win_count <- function(k_ends_old, k_ends_new){
#setting up global variables to use later
win_counter = 0
tie_counter = 0
losses_counter = 0 #just to check that I can do addition
min_bkpt = 0
max_bkpt = 0
#finds what exactly what the delted breakpoint is
dead_bkpt = setdiff(k_ends_old,k_ends_new)
#finds location of deleted break point in the original k_ends
dead_bkpt_grave = 0
for(i in 1:length(k_ends_old)){
if (k_ends_old[i] == dead_bkpt){
dead_bkpt_grave = i
}
}
#sets the min and max scores for the deleted breakpoint
right = k_ends_old[dead_bkpt_grave]-k_ends_old[dead_bkpt_grave-1]
left = k_ends_old[dead_bkpt_grave+1]-k_ends_old[dead_bkpt_grave]
if(right > left){
max_bkpt = right
min_bkpt = left
}else{
max_bkpt = left
min_bkpt = right
}
scoring_list = list_of_scores(k_ends_old)  #calculates a scoring list for k_ends_old
hasWon = "no" #boolean will check to see if the point has already won match
#goes through the list and counts wins, ties, and losses
for(i in 1:length(scoring_list)){
if(i %% 2 != 0){#if i is odd, we're looking at minimums for the first time
hasWon = "no" #just makes sure that hasWon is set to no
if(min_bkpt< scoring_list[i]){ #if the breakpoint's minimum is less than the scorelist it won minimum
win_counter = win_counter+1 #increase the win counter by 1
hasWon = "yes" #the break point won so nothing else will need to happen
}#if(min_bkpt >= scoring_list[i]) don't do anything
}else if (i %% 2 == 0 && hasWon == "no"){#if i is even and it hasnt won, look at the maximum
if(max_bkpt < scoring_list[i]){#if the breakpoint's maximum is less than the scorelit it won maximum
win_counter = win_counter+1 #increase the win counter by 1
}
else if(max_bkpt == scoring_list[i]){#if they're equal, then it's a tie
tie_counter = tie_counter+0.5 #increase the tie counter by .5
}
else{#the breakpoint loss =( so increaste the loss counter
losses_counter = losses_+1 #im so sorry for your loss
}
}
}
#with current set up there is an occassion where the point is compared to itself
#such a case will result in a tie
#therefore, we need to remove one tie case
tie_counter = tie_counter-0.5
#now we need to add the total number of wins and ties
total_count = win_counter+tie_counter
return(total_count)
}
#FUNCTION THREE
#calculates the second part of the q algorithm for sub
#inputs: k_ends_old, k_ends_new,
#rhow --- probability of choosing a random subtraction instead of our created subtraction
part_two_q_sub_score <- function(k_ends_old, k_ends_new, rhow){
numerator = breakpoint_win_count(k_ends_old, k_ends_new)
denomenator = choose(length(k_ends_old)-2, 2)
part_2 = (numerator/denomenator)*(1-rhow)+(rhow)*(1/length(k_ends_old)-2)
return(part_2)
}
part_two_q_sub_score(c(1,30,60,90), c(1,30,90), .3)
