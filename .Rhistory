theme(axis.text.x = element_text(colour = "blue"))
ggplot(cdc, aes(x=weight,y=age)) +
geom_point(aes(col=genhlth)) +
labs(title="Age as a function of Weight", subtitle="Data from cdc", y="Age",x="Weight", caption="Colored by General Health") +
scale_colour_brewer(palette = "Set1") +
theme_classic() +
theme(plot.background = element_rect(fill = "gray")) +
theme(axis.text = element_text(colour = "darkblue")) +
themetext.title = element_text(colour = "blue"))
ggplot(cdc, aes(x=weight,y=age)) +
geom_point(aes(col=genhlth)) +
labs(title="Age as a function of Weight", subtitle="Data from cdc", y="Age",x="Weight", caption="Colored by General Health") +
scale_colour_brewer(palette = "Set1") +
theme_classic() +
theme(plot.background = element_rect(fill = "gray")) +
theme(axis.text = element_text(colour = "darkblue"))
ggplot(cdc, aes(x=weight,y=age)) +
geom_point(aes(col=genhlth)) +
labs(title="Age as a function of Weight", subtitle="Data from cdc", y="Age",x="Weight", caption="Colored by General Health") +
scale_colour_brewer(palette = "Set1") +
theme_classic() +
theme(plot.background = element_rect(fill = "gray")) +
theme(axis.text = element_text(colour = "darkblue")) +
theme(plot.title = element_text(colour = "darkblue"))
ggplot(cdc, aes(x=weight,y=age)) +
geom_point(aes(col=gender)) +
labs(title="Age as a function of Weight", subtitle="Data from cdc", y="Age",x="Weight", caption="Colored by General Health") +
scale_colour_brewer(palette = "Set1") +
theme_classic() +
theme(plot.background = element_rect(fill = "gray")) +
theme(axis.text = element_text(colour = "darkblue")) +
theme(plot.title = element_text(colour = "darkblue"))
ggplot(cdc, aes(x=weight,y=age)) +
geom_point(aes(col=gender)) +
labs(title="Age as a function of Weight", subtitle="Data from cdc", y="Age",x="Weight", caption="Colored by Gender") +
scale_colour_brewer(palette = "Set1") +
theme_classic() +
theme(plot.background = element_rect(fill = "gray")) +
theme(axis.text = element_text(colour = "darkblue")) +
theme(plot.title = element_text(colour = "darkblue"))
cdc$gender2 = if(cdc$gender == "f") { cdc$gender ="Female" }
cdc$gender1 = ifelse(cdc$gender == "m","Male","Female")
ggplot(cdc, aes(x=weight,y=age)) +
geom_point(aes(col=gender1)) +
labs(title="Age as a function of Weight", subtitle="Data from cdc", y="Age",x="Weight", caption="Colored by Gender") +
scale_colour_brewer(palette = "Set1") +
theme_classic() +
theme(plot.background = element_rect(fill = "gray")) +
theme(axis.text = element_text(colour = "darkblue")) +
theme(plot.title = element_text(colour = "darkblue"))
ggplot(cdc, aes(x=weight,y=age)) +
geom_point(aes(col=gender1)) +
labs(title="Age as a function of Weight", subtitle="Data from cdc", y="Age",x="Weight", caption="Colored by Gender") +
scale_colour_brewer(palette = "Set1") +
theme_classic() +
theme(plot.background = element_rect(fill = "gray")) +
theme(axis.text = element_text(colour = "darkblue")) +
theme(plot.title = element_text(colour = "darkblue")) +
theme(plot.subtitle = element_text(colour = "darkred"))
qplot(weight, age, data=cdc)  #since age is a function it has to be on the y axis
ggplot(cdc, aes(x=weight,y=age)) +
geom_point(aes(col=gender1)) +
labs(title="Age as a function of Weight", subtitle="Data from cdc", y="Age",x="Weight", caption="Colored by Gender") +
scale_colour_brewer(palette = "Set1") +
theme_classic() +
theme(plot.background = element_rect(fill = "gray")) +
theme(axis.text = element_text(colour = "darkblue")) +
theme(plot.title = element_text(colour = "darkblue")) +
theme(plot.subtitle = element_text(colour = "darkred"))
graphics.off()
rm(list=ls())
cat("\014")
gg <- ggplot(midwest, aes(x=area, y=poptotal)) +
geom_point(aes(col=state, size=popdensity)) +
geom_smooth(method="lm", se=T) +
xlim(c(0, 0.1)) +
ylim(c(0, 500000)) +
labs(subtitle="Area Vs Population",
y="Population",
x="Area",
title="Scatterplot",
caption = "Source: midwest")
gg+theme_classic()
g <- ggplot(midwest, aes(x=area, y=poptotal)) +
geom_boxplot(aes(fil=state)) +
labs(title="Boxplot",
caption = "Source: midwest",
subtitle = "Area Vs Population")
g+theme_classic()
g <- ggplot(midwest, aes(x=area, y=poptotal)) +
geom_boxplot(aes(fil=state)) +
labs(title="Boxplot",
caption = "Source: midwest",
subtitle = "Area Vs Population") +
ylim(c(0,100000))
g+theme_classic()
g <- ggplot(midwest, aes(x=area, y=poptotal)) +
geom_boxplot(aes(fill=state)) +
labs(title="Boxplot",
caption = "Source: midwest",
subtitle = "Area Vs Population") +
ylim(c(0,100000))
g+theme_classic()
g <- ggplot(midwest, aes(x=area, y=poptotal))
g +  geom_boxplot(aes(fill=state)) +
labs(title="Boxplot",
caption = "Source: midwest",
subtitle = "Area Vs Population") +
ylim(c(0,100000)) +
theme_classic()
g <- ggplot(midwest, aes(x=state, y=poptotal))
g +  geom_boxplot(aes(fill=state)) +
labs(title="Boxplot",
caption = "Source: midwest",
subtitle = "Area Vs Population") +
ylim(c(0,100000)) +
theme_classic()
g + geom_boxplot(aes(fill = state)) +
labs(title="Boxplot",
caption = "Source: midwest",
subtitle = "Area Vs Population" ) +
ylim(c(0,100000)) +
theme(legend.position="None") +
theme_classic()
g + geom_boxplot(aes(fill = state)) +
labs(title="Boxplot",
caption = "Source: midwest",
subtitle = "Area Vs Population" ) +
ylim(c(0,100000)) +
theme(legend.position="None")
g + geom_boxplot(aes(fill = state)) +
labs(title="Boxplot",
caption = "Source: midwest",
subtitle = "Area Vs Population" ) +
ylim(c(0,100000)) +
theme_classic(legend.position="None")
g + geom_boxplot(aes(fill = state)) +
labs(title="Boxplot",
caption = "Source: midwest",
subtitle = "Area Vs Population" ) +
ylim(c(0,100000)) +
theme_classic(legend.position="None")
g + geom_boxplot(aes(fill = state)) +
labs(title="Boxplot",
caption = "Source: midwest",
subtitle = "Area Vs Population" ) +
ylim(c(0,100000)) +
theme(legend.position="None")
g + geom_boxplot(aes(fill = state)) +
labs(title="Boxplot",
caption = "Source: midwest",
subtitle = "Area Vs Population" ) +
ylim(c(0,100000)) +
theme(legend.position="None") +
theme_classic()
g + geom_boxplot(aes(fill = state)) +
labs(title="Boxplot",
caption = "Source: midwest",
subtitle = "Area Vs Population" ) +
ylim(c(0,100000)) +
theme(legend.position="None")
g + geom_boxplot(aes(fill = state)) +
labs(title="Boxplot",
caption = "Source: midwest",
subtitle = "Area Vs Population" ) +
theme_classic() +
ylim(c(0,100000)) +
theme(legend.position="None")
?mpg
attach(mpg)
manufacturer[1:10]
manufacturer[1:20]
ggg <- ggplot(mpg, aes(manufacturer))
ggg + geom_bar(aes(fill=class), width = 0.5)
ggg <- ggplot(mpg, aes(manufacturer))
ggg + geom_bar(aes(fill=class), width = 0.5) +
labs(title = "Histogram on Categorical Variable")
source("http://foxweb.marist.edu/users/duy.nguyen2/cdc.R")
head(cdc)
ggplot(cdc, aes(genhlth)) +
geom_boxplot()
ggplot(cdc, aes(age)) +
geom_boxplot(aes(genhlth))
ggplot(cdc, aes( x=genhlth,y=age)) +
geom_boxplot(aes(genhlth))
ggplot(cdc, aes( x=genhlth,y=age)) +
geom_boxplot(aes(fill=genhlth)))
ggplot(cdc, aes( x=genhlth,y=age)) +
geom_boxplot(aes(fill=genhlth))
ggplot(cdc, aes( x=age, y=gender)) +
geom_boxplot(aes(fill=gender))
ggplot(cdc, aes( x=gender, y=age)) +
geom_boxplot(aes(fill=gender))
ggplot(cdc, aes(x=smoke100, y=age)) +
geom_boxplot(aes(fill=smoke100))
ggplot(cdc, aes(x=smoke100, y=age)) +
geom_boxplot()
cdc$smoke = ifelse(cdc$smoke100 == "1", "Smoker", "Non-Smoker")
ggplot(cdc, aes(x=smoke, y=age)) +
geom_boxplot()
ggplot(cdc, aes(x=smoke, y=age)) +
geom_boxplot(aes(fill=smoke))
cdc$smoke = ifelse(cdc$smoke100 == "1", "Smoker", "Non-Smoker")
ggplot(cdc, aes(x=smoke, y=age)) +
geom_boxplot(aes(fill=smoke)) +
theme(legend.position="None")
ggplot(cdc, aes(x=smoke, y=age)) +
geom_boxplot(aes(fill=smoke)) +
labs(title="Smoker and Age") +
theme(legend.position="None")
ggplot(cdc, aes( x=genhlth,y=age)) +
geom_boxplot(aes(fill=genhlth)) +
labs(title="genhlth and Age")
theme(legend.position="None")
ggplot(cdc, aes( x=genhlth,y=age)) +
geom_boxplot(aes(fill=genhlth)) +
labs(title="genhlth and Age") +
theme(legend.position="None")
first = rnorm(30, mean = 5, sd = 1) #30 random data points from a normal distribution with means 5
second = rnorm(30, mean = 15, sd = 1) #30 random data points from a normal distribution with means 15
third = rnorm(30, mean = 30, sd = 1)
dif_means = c(first, second) #adding the two sets of data points together
dif_means_2 = c(first, second, third)
time = c(1:60) #making time
test_data = data.frame(time, dif_means) #our data with x = time and y = two sets of data with two means
plot(test_data, main="Initial Data with Means Equal to 5 and 15")
neuron = read.table("exampledata.txt")
setwd("~/REU2018")
neuron = read.table("exampledata.txt")
library(splines)
library("strucchange")
dif_means_neuron<-ts(neuron[,2], start=1, end=110) #create time series data on only the first data
breakpoints(dif_means_neuron ~ 1, breaks = 5) #no break points
plot(dif_means_neuron)
points(43,neuron[43,2], col="purple", pch= 18)
points(60,neuron[60,2], col="purple", pch= 18)
points(90,neuron[90,2], col="purple", pch= 18)
plot(neuron, xlab="Seconds", ylab="Number of Firing Events", main="Neuron Data, df = 3")
points(43,neuron[43,2], col="purple", pch= 18)
points(60,neuron[60,2], col="purple", pch= 18)
points(90,neuron[90,2], col="purple", pch= 18)
plot(dif_means_neuron)
points(43,neuron[43,2], col="purple", pch= 18)
points(60,neuron[60,2], col="purple", pch= 18)
points(90,neuron[90,2], col="purple", pch= 18)
breakpoints(dif_means_neuron ~ 1, breaks = 5, h=0) #no break points
breakpoints(dif_means_neuron ~ 1, breaks = 5, h=.05) #no break points
plot(dif_means_neuron)
plot(dif_means_neuron)
points(43,neuron[43,2], col="purple", pch= 18)
points(48,neuron[48,2], col="purple", pch= 18)
points(56,neuron[56,2], col="purple", pch= 18)
points(72,neuron[72,2], col="purple", pch= 18)
points(98,neuron[98,2], col="purple", pch= 18)
dif_means_ts_0<-ts(first, start=1, end=30, h=0.5) #create time series data on only the first data
dif_means_ts_0<-ts(first, start=1, end=30, h=0.05) #create time series data on only the first data
first = rnorm(30, mean = 5, sd = 1) #30 random data points from a normal distribution with means 5
second = rnorm(30, mean = 15, sd = 1) #30 random data points from a normal distribution with means 15
third = rnorm(30, mean = 30, sd = 1)
dif_means = c(first, second) #adding the two sets of data points together
dif_means_2 = c(first, second, third)
time = c(1:60) #making time
test_data = data.frame(time, dif_means) #our data with x = time and y = two sets of data with two means
plot(test_data, main="Initial Data with Means Equal to 5 and 15")
library("strucchange")
?breakpoints
dif_means_ts_0<-ts(first, start=1, end=30, h=0.05) #create time series data on only the first data
dif_means_ts_0<-ts(first, start=1,end=30) #create time series data on only the first data
breakpoints(dif_means_ts_0 ~ 1, breaks = 2 , h=0.05) #no break points
breakpoints(dif_means_ts_0 ~ 1, breaks = 2 , h=0.005) #no break points
breakpoints(dif_means_ts_0 ~ 1, breaks = 2 , h=0.001) #no break points
breakpoints(dif_means_ts_0 ~ 1, breaks = 2 , h=0.1) #no break points
dif_means_ts_1<-ts(dif_means, start=1, end=60) #create time series data with first and second data
breakpoints(dif_means_ts_1 ~ 1, breaks = 2 , h=0.1) #one break
breakpoints(dif_means_ts_2 ~ 1, breaks=3, , h=0.1) #two breaks
dif_means_ts_2<-ts(dif_means_2, start=1, end=90) #create time series data with first second and third data
breakpoints(dif_means_ts_2 ~ 1, breaks=3, , h=0.1) #two breaks
plot(dif_means_ts_0)
plot(dif_means_ts_1)
points(30, if_means_ts_1[30,])
points(30, if_means_ts_1[30])
points(30, dif_means_ts_1[30])
points(30, dif_means_ts_1[30], col="purple", pch= 18)
dif_means_ts_2<-ts(dif_means_2, start=1, end=90) #create time series data with first second and third data
breakpoints(dif_means_ts_2 ~ 1, breaks=3, , h=0.1) #two breaks
dif_means_ts_2<-ts(dif_means_2, start=1, end=90) #create time series data with first second and third data
breakpoints(dif_means_ts_2 ~ 1, breaks=3, , h=0.1) #two breaks
plot(dif_means_ts_2)
points(30, dif_means_ts_2[30], col="purple", pch= 18)
points(60, dif_means_ts_2[60], col="purple", pch= 18)
?runif
u = runif(1)
u
u = runif()
?sse
?SSE
#setting up data
first = rnorm(30, mean = 5, sd = 1) #30 random data points from a normal distribution with means 5
#addition attempt
#setting up data
first = rnorm(30, mean = 5, sd = 1) #30 random data points from a normal distribution with means 5
second = rnorm(30, mean = 15, sd = 1)
dif_means = c(first, second) #putting the two generated number list together
time = c(1:60) #making time
test_data = data.frame(time, dif_means) #making a data frame of it
k = c(4,10,15,45,50) #pretending that these are the break points
d = diff(k) #finding te distance between all those break points
location = which.max(d) #finding the location of the farthest distance
min = k[location] #lower bound
max = k[location + 1] #upper bound
new_additon = sample(min:max, 1) #selecting a random number in the correct interval
new_additon
plot(test_data) #plotting the original data
points(new_additon, dif_means[new_additon], col="red", pch= 17) #plotting the new break point
points(k, dif_means[k], col="blue", pch=17) #plotting all the other break points
dif_means_ts_2<-ts(dif_means_2, start=1, end=90) #create time series data with first second and third data
#downloading the strucchange package
install.packages("strucchange")
library("strucchange")
?breakpoints
#downloading the strucchange package
install.packages("strucchange")
#downloading the strucchange package
#install.packages("strucchange")
library("strucchange")
#creating our data
first = rnorm(30, mean = 5, sd = 1) #30 random data points from a normal distribution with mean of 5
second = rnorm(30, mean = 15, sd = 1) #30 random data points from a normal distribution with mean of 15
third = rnorm(30, mean = 30, sd = 1) #30 random data points from a normal distribution with mean of 30
dif_means_0 = c(first) #setting up null set
dif_means_1 = c(first, second) #adding two sets of data points together
dif_means_2 = c(first, second, third) #adding three sets of data points together
time_0 = 1:30
time_1 = 1:60
time_2 = 1:90
test_data_0 = data.frame(time_0, dif_means_0) #our data with x = time and y = data from 1 set
test_data_1 = data.frame(time_1, dif_means_1) #our data with x = time and y = data from 2 sets
test_data_2 = data.frame(time_2, dif_means_2) #our data with x = time and y = data from 3 sets
#downloading the strucchange package
#install.packages("strucchange")
library("strucchange")
#Bai-Perron Method
bkpts_0 = breakpoints(test_data_0$dif_means_0 ~ test_data_0$time_0, breaks = 5, h = 0.1) #no break points
bkpts_0$breakpoints #list of x-values (time) for breakpoints
bkpts_1 = breakpoints(test_data_1$dif_means_1 ~ test_data_1$time_1, breaks = 5, h = 0.1) #no break points
bkpts_1$breakpoints #list of x-values (time) for breakpoints
bkpts_2 = breakpoints(test_data_2$dif_means_2 ~ test_data_2$time_2, breaks = 5, h = 0.1) #no break points
bkpts_2$breakpoints #list of x-values (time) for breakpoints
test_k <- c(1,30,60)
test_k_2 <- c(1,30,50,60)
fitMetrics<-function(k_ends, test_data){
#create sum objects
sum_sd = 0
sum_SSE = 0
#get and sum standard deviation and SSE for regressions of all intervals
for(i in 1:length(k_ends)) {
if(k_ends[i] != 1){
min = k_ends[i-1]
x_values = test_data[c(min:i),1] #getting the x values in the interval
y_values = test_data[c(min:i),2] #getting the y values in the interval
data = data.frame(x_values, y_values) #re-making this into a dataframe
sum_sd = sum_sd + sd(y_values) #adding up all the standard deviations
model = lm(y_values~x_values)
SSE = sum(model$residuals^2)
sum_SSE = sum_SSE + SSE #adding up all the SSEs
}
}
print(c(sum_sd,sum_SSE))
}
new_metrics = fitMetrics(test_k, test_data_1)
old_metrics = fitMetrics(test_k_2, test_data_1)
sigma_new = new_metrics[1]
sigma_old = old_metrics[1]
SSE_new = new_metrics[2]
SSE_old = old_metrics[2]
ratio = exp(-1/(2 * sigma_new) * SSE_new) + exp(-1/(2 * sigma_old) * SSE_old)
u = runif(1) #random number from 0 to 1 taken from a normal distrabution
#our temporary L
if(ratio > 1) {
print("new")
} else if(ratio > u) {
print("new")
} else {
print("old")
}
barMake1(k_ends_test)
#addition attempt one (random point in largest interval)
k_ends_test = c(1,50,60)
barMake1<-function(k_ends){
d = diff(k_ends) #finding the distance between all those breakpoints
locations = which(d == max(d) ) #finding the location(s) of the farthest distance
location = sample(locations, 1) #randomly select location in case of equal max distances
min = k_ends[location] #lower bound
max = k_ends[location + 1] #upper bound
new_bp = sample((min+1):(max-1), 1) #selecting a random number in the correct interval
newSet = sort(c(k_ends, new_bp))
newSet
}
barMake1(k_ends_test)
#random murder
random_num = sample(1:length(k), 1)
k[random_num]
View(bkpts_2)
View(bkpts_1)
#random murder
random_num = sample(1:length(k), 1)
k[random_num]
#random make
random_spot = sample(1:length(test_data_1), 1)
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot]
test_data_1[random_spot,]
#random make
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
#random make
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
#random make
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
#random murder
random_num = sample(1:length(k), 1)
k[random_num]
barMake1(k_ends_test)
#random murder
random_num = sample(1:length(k), 1)
k[random_num]
#random murder
k=c(1,30,60)
random_num = sample(1:length(k), 1)
k[random_num]
#random make
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
#random make
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
#random make
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
#random murder
k=c(1,5,7,17,30,45, 50, 55, 60)
random_num = sample(1:length(k), 1)
k[random_num]
#random make
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
random_spot = sample(1:length(test_data_1), 1)
test_data_1[random_spot,]
jiggle<-function(percent, data_length, k_ends){
#determines how much the knot shoud jiggle
jiggle_range = ceiling(percent*data_length)
jiggle_neighborhood = c(1:jiggle_range)
jiggle_spot = sample(1:jiggle_neighborhood, 1)
#determines randomly if knot is jiggling to left or right
direction = "right" #default direction is right
u = runif(1) #random number from 0-1 from uniform distribution
if(u < 0.5){
direction = "left"
jiggle_spot = (-1)*jiggle_spot
}
#determines randomly which knot is jiggling (code related to murders)
k = k_ends[c(-1, -length(k_ends))] #removes end points
rando_knot = sample(1:length(k),1) #chooses random knot
#"boolean" variable to make sure that we can jiggle
can_jiggle = "good" #default is good and we can jiggle
#check if we can jiggle towards an endpoint
if(direction = right){
right_end = k_ends[length(k_ends)]
if(right_end < rando_knot+jiggle_spot){
can_jiggle = "bad"
}
}else{
left_end = k_ends[1]
if(left_end > rando_knot+jiggle_spot){
can_jiggle = "bad"
}
}
#check if new knot location already has a knot there
possible_knot = rando_knot+jiggle_spot
for(i in 1:length(k)){
if(possible_knot == k[i]){
can_jiggle = "bad"
}
}
#check if we can jiggle, then jiggle!!!
if(can_jiggle == bad){
return()
}else{
print(rando_knot)
middle_set = k_ends[-(rando_knot)]
print(possible_knot)
final_set = sort(c(middle_set,possible_knot))
final_set
}
}
jiggle_spot = sample(1:jiggle_neighborhood,1)
